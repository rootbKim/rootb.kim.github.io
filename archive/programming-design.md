---
layout: note_page
title: 프로그래밍 디자인 (1) - 정의와 원칙
tags: [Programming]
category: "Programming"
---

`전문가를 위한 C++(마크 그레고리 / 한빛미디어)`에서 제안된 프로그래밍 디자인 방법에 대해 정리한다.


# 1. 프로그래밍 디자인이란?

## 1.1 프로그램 디자인의 정의

### 1.1.1 요구사항 분석
프로젝트를 새로 시작하거나 기존에 구현했던 프로그램을 개선하기 시작할 때 가장 먼저 해야할 일이 요구사항을 분석하는 것이다.

* 기능 요구사항 문서 : 이해 당사자와 함께 논의하는 단계에서 산출되는 결과로 코드가 정확히 할 일만 표현하고, 그 일을 달성하는 구체적인 방법은 생략
* 비기능 요구사항 문서 : 시스템에 대한 동작이 아닌 속성을 표현함. 예를 들어 시스템이 보안에 뛰어나고, 확장성도 높고, 일정한 성능 기준을 만족해야 한다는 식으로 표현

### 1.1.2 프로그램 디자인(소프트웨어 디자인)
다음 단계로 프로그램 디자인 또는 소프트웨어 디자인 단계로 넘어간다. 이 단계는 앞 단계에서 도출한 기능 및 비기능 요구사항을 모두 만족하는 프로그램을 구현하기 위한 구조에 대한 명세서다.

1. 프로그램을 구성하는 서브시스템 : 인터페이스와 서브시스템 사이의 의존성, 서브시스템 사이의 데이터 흐름, 서브시스템에 대한 입출력, 기본 스레드 활용 모델
2. 서브시스템별 세부사항 : 클래스 구성, 클래스 계층도, 데이터 구조, 알고리즘, 개별 스레드 활용 모델, 에러 처리 방법

디자인 문서는 대체로 서브시스템 사이의 상호작용과 클래스 계층을 보여주는 다이어그램이나 표로 구성된다. 일반저긴 업계 표준은 UML(Uinified Modeling Language)을 사용한다.

## 1.2. 프로그램 디자인의 중요성

프로젝트를 여러 팀원이 나눠서 진행하는 경우, 공통적으로 따르는 디자인을 반드시 문서 형태로 마련해야 한다.

이러한 디자인을 제대로 하지 않고 프로그래밍을 하는 경우, 문제를 어설프게 해결하게 된다. 이는 한참 구현을 진행하고 난 이후 문제점을 발견하고 수정하려고 하다보면 불필요한 코드들이 늘어나게 될 것이다.

이렇게 디자인을 통해 큰 그림을 보지 못하면 사소한 구현 세부사항에 빠져 전체 구조와 목적을 놓치기 쉽다. 따라서 모든 프로젝트 팀원이 참조할 수 있는 디자인 문서를 만들고 항상 최신 상태로 유지해야 한다.

## 1.3. C++에 적합한 디자인 방법

C++은 방대한 기능을 제공하기 때문에, 다양한 기능을 활용하기 위한 디자인 작업이 필요하며, 객체지향적으로 디자인해야 한다. 이러한 C++은 다양한 디자인 패턴이나 널리 알려진 문제 해결 기법을 곧바로 적용하기 좋다.

이러한 디자인 과정은 매우 오래 걸리고 오랜 훈련이 필요한 과정이다.

# 2. C++ 디자인을 위한 2 가지 원칙

## 2.1. 추상화
추상화(abstraction)은 내부 구현과 외부 인터페이스를 분리하는 것이다. 내부 구현 방식을 이해하지 않아도 코드를 쉽게 사용할 수 있게 구성해야 한다.

간단한 예로 `<cmath>` 헤더 파일에 선언된 `sqrt()` 함수를 호출하는 경우에, 이 함수가 제곱근을 구하는 데 내부적으로 사용하는 알고리즘을 몰라도 된다. 실제로 제곱근 계산에 대한 내부 구현은 라이브러리 버전마다 달라질 수 있는데, 인터페이스만 그대로 유지된다면 기존에 이 함수를 호출한 코드는 버전 변화에 아무런 영향을 받지 않는다.

구체적인 예로 체스 프로그램을 만들기 위해 구현한 체스보드를 다음과 같이 2차원 포인터 배열로 구현한다.
```cpp
ChessPiece* chessBoard[8][8];
...
chessBoard[0][0] = new Rook();
```

하지만 이렇게 하면 체스보드를 사용하는 프로그래머가 항상 체스보드가 2차원 배열로 구현됐다는 사실을 알아야 하기 때문에 추상화 원칙에 어긋난다.
또한, 이러한 문제를 해결하기 위해 크기가 64인 1차원 vector로 변경하게 되는 경우에 문제가 된다. 프로그램 코드 전체를 뒤져서 체스보드를 사용한 부분을 일일이 수정해야 하기 때문이다. 또한 체스보드를 사용하는 측에서 메모리 조작 과정에 문제가 발생하지 않도록 직접 관리해야 한다.

이러한 문제를 해결하기 위해 체스보드 모델을 클래스로 작성해야 한다. 그런 다음 인터페이스를 공개하고 그 뒤에 구현에 대한 세부사항을 숨긴다.
```cpp
class ChessBoard
{
    public:
        // 생성자, 소멸자, 대입 연산자 생략
        void setPieceAt(size_t x, size_t y, ChessPiece* piece);
        ChessPiece* getPieceAt(size_t x, size_t y);
        bool isEmpty(size_t x, size_t y) const;
    private:
        // 데이너 멤버 코드 생략
};
```
이 인터페이스는 내부 구현에 대한 코드가 한 줄도 나오지 않았다. ChessBoard를 2차원 배열로 구현하더라도 인터페이스에 전혀 어긋나지 않는다. 구현 방식이 바뀌더라도 인터페이스를 그대로 유지할 수 있다. 게다가 구현 코드에서 기능을 추가로 제공할 수 있다.

## 2.2. 재사용
재사용(reuse)은 프로그래밍을 할 때 직접 구현할 필요가 없는 부분은 해당 기능을 제공하는 코드를 적절히 골라서 현재 프로그램에 재사용하는 것이다. 이러한 재사용 원칙은 직접 작성한 코드뿐만 아니라 가져다 쓰는 코드에도 똑같이 적용된다.

## 2.2.1 재사용 가능한 코드 만들기
프로그램을 작성할 때 클래스, 알고리즘, 데이터 구조를 재사용할 수 있도록 디자인해야 한다. 그래서 자신 뿐만 아니라 다른 동료도 현재 프로젝트나 향후 프로젝트에서 활용할 수 있어야 한다. 따라서 당장 주어진 문제에만 적용할 수 있도록 너무 특화된 형태로 디자인하지 않는 것이 좋다.

C++은 코드를 범용적으로 만들 수 있도록 **템플릿**이라는 기능을 제공한다. 다음 예제는 템플릿을 이용하여 데이터 구조를 만드는 예를 보여준다.
```cpp
template <typename PieceType>
class GameBoard
{
    public:
        // 생성자, 소멸자, 대입 연산자 생략
        void setPieceAt(size_t x, size_t y, PieceType* piece);
        PieceType* getPieceAt(size_t x, size_t y);
        bool isEmpty(size_t x, size_t y) const;
    private:
        // 데이너 멤버 코드 생략
}
```

앞선 예제처럼 ChessPiece를 저장하는 ChessBoard를 너무 구체적으로 작성하지 않고, 체스나 체커와 같이 2차원 보드를 사용하는 게임이라면 언제든지 적용할 수 있도록 GameBoard라는 제네릭 템플릿으로 정의하였다. 또한 게임에 사용할 말을 인터페이스에 고정시키지 말고 템플릿 매개변수로 전달하도록 클래스 선언을 변경하였다.

## 2.2.2 디자인 재사용
C++ 프로그래밍에 사용되는 프로그램 디자인 기법과 디자인 패턴을 최대한 활용하여 프로그래밍을 해야 한다. 이렇게 하려면 여러 가지 패턴과 기법을 잘 익혀둬야 한다. 그래야 주어진 디자인 문제에 어떤 해결책을 적용할지 판단할 수 있다.

## 2.2.3 코드의 재사용
재사용 할 수 있는 코드 유형은 다음과 같다.
* 예전에 자신이 작성했던 코드
* 동료가 작성한 코드
* 현재 소속 회사나 조직 외의 서드파티에서 작성한 코드

재사용할 코드를 만드는 형식도 다음과 같이 다양하다.
* 독립 함수 또는 클래스 : 자신 또는 동료가 작성한 코드의 대부분의 형태
* 라이브러리 : 특정한 작업을 처리하는 데 필요한 코드를 한데 묶은 것
* 프레임워크 : 디자인할 프로그램의 기반이 되는 코드를 모아둔 것

코드 재사용 여부는 주어진 상황과 목적에 따라 판단해야 한다. 직접 작성하는 데 걸리는 시간과 주어진 문제에 적절한 라이브러리를 찾아서 사용법을 익히는 데 걸리는 시간을 잘 비교해서 결정해야 하는 경우가 많다.

> 코드를 재사용하는 것이 적합한지, 어느 코드를 사용해야 할지는 상황에 맞게 결정해야 한다. 항상 장단점이 존재하기 때문에 다음과 같은 전략을 고려하여 재사용 여부 및 재사용 코드를 선정하는 것이 좋다.
> 1. 기능과 제약사항 파악하기
> 2. 성능 파악하기
> 3. 플랫폼 제약사항 파악하기
> 4. 라이선스와 기술 지원 파악하기
> 5. 도움을 받을 수 있는 곳 파악하기
> 6. 프로토타입