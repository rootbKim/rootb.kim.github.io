---
layout: archive
title: C++ 3/5/0의 규칙
tags: [C++]
category: "Programming"
---

C++의 클래스 생성 규칙인 3의 규칙, 5의 규칙, 0의 규칙에 대해서 정리한다.

# 3의 규칙

`3의 규칙`은 클래스 생성 시 `소멸자`, `복제 생성자`, `복제 대입 연산자` 중 `default`가 아닌 사용자가 하나 이상 구현을 해야 한다면, 3 가지의 기능을 모두 구현해야 한다는 규칙이다. 즉, 소멸자를 디폴트 소멸자가 아닌 사용자가 정의해야 하는 소멸자인 경우에 복제 생성자와 복제 대입 연산자를 무조건적으로 생성해야 한다는 것이다.

그렇다면 소멸자를 정의해야 하는 경우가 어떤 경우인지 살펴보면, 주로 클래스 내에 힙 객체를 하나 이상 사용하는 경우 자동으로 삭제되지 않기 때문에, 객체 포인터에 대해 명시적으로 `delete`를 호출해서 그 객체의 소멸자를 호출하고 메모리를 해제해야 한다. 이런 경우에 복제를 하는 경우에도 디폴트 복제 생성자 또는 디폴트 복제 대입 연산자를 사용하면 `얕은 복사`가 이루어지기 때문에 문제가 될 수 있다. 따라서 사용자가 직접 `깊은 복사`가 이루어지도록 복제 생성자와 복제 대입 연산자를 구현해야만 한다.

# 5의 규칙

`3의 규칙`과 동일하게 `5의 규칙`은 클래스 생성 시 `소멸자`, `복제 생성자`, `복제 대입 연산자`에 더해 `이동 생성자`, `이동 대입 연산자` 까지 5개 중 하나 이상을 구현해야 한다면 5 가지의 기능을 모두 구현해야 한다는 규칙이다. 

> `5의 규칙`은 `C++11`부터 `이동 의미론`이 추가되면서, 이 이동 의미론을 적용하기 위해서는 `이동 생성자`와 `이동 대입 연산자`를 정의해야 한다. 

3의 규칙과 동일하게 주로 클래스 내에 힙 객체를 하나 이상 사용하는 경우에 위 5 가지 기능을 모두 구현해야 한다.

> 아니면 `delete`를 키워드를 이용하여 해당 기능을 명시적으로 삭제하여 사용하지 못하게 하는 것도 하나의 방법이다!

> `복제 생성자`, `복제 대입 연산자`, `이동 생성자`, `이동 대입 연산자`의 생성 방법은 다른 포스트에서 자세하게 다루도록 한다.

# 0의 규칙

`0의 규칙`은 `5의 규칙`과 반대되는 개념으로, 5의 규칙은 5가지 기능 중 하나라도 디폴트 기능을 사용하지 못한다면 5개의 기능을 모두 사용자가 구현해야 한다는 것이었는데, 이와 반대로 0의 규칙은 위의 5가지 기능을 구현할 필요가 없도록 클래스를 디자인해야 한다는 것이다.

즉 디폴트 기능을 사용할 수 있도록 힙에 메모리를 동적으로 할당하지 않고, 표준 라이브러리 컨테이너와 같은 최신 구문을 활용해야 0의 규칙을 만족시킬 수 있다.

그렇다면 메모리를 동적으로 할당해야 하는 클래스의 경우 0의 규칙을 어떻게 만족할 수 있을까? 바로 `std::unique_ptr`과 `std::shared_ptr`을 사용하는 것이다. 클래스 내에 `std::unique_ptr` 객체를 가지고 있다면, 이동은 가능하고, 복제는 불가능할 것이다. 이동과 복제를 둘 다 가능하게 하려면 클래스 내에 동적 할당 객체를 `std::shared_ptr` 객체로 사용하면 될 것이다. 하지만 멤버 변수 중 하나라도 `std::unique_ptr`를 가지고 있다면 클래스 전체의 복제는 불가능할 것이다.

그 이외에도 문자열의 경우 동적으로 할당된 문자 배열(`char*`)보다는 복사와 이동 의미론을 모두 만족하는 `std::string`을 사용하고, 표준 라이브러리 컨테이너 클래스를 사용하는 것이 0의 규칙을 만족시킬 수 있는 방법이 될 것이다.

C++의 유일한 내장 컨테이너인 배열 또한 포인터의 특성을 가지고 있기 때문에 단순 대입이나 이동이 불가능하다. 대신 C++에서는 `vector`나 `map`과 같이 유용한 표준 라이브러리 컨테이너들을 제공한다. 이러한 컨테이너들은 `복제`나 `이동`에 대한 기능을 모두 지원하기 때문에 0의 규칙을 만족시킬 수 있다.

# 결론

스마트 포인터를 사용하지 않고 힙에 동적으로 할당해야 하는 경우에는 `C++11` 이상을 사용하는 경우 `5의 규칙`을 지켜야 하지만, 그렇지 않은 경우에는 스마트 포인터와 표준 라이브러리 컨테이너들을 이용하여 `0의 규칙`을 만족시키게 클래스를 구현한다면 클래스를 좀 더 간단하고 깔끔하게 구현할 수 있을 것이다.

조금 더 범용적으로 정리를 하면, 클래스 내부에 선언된 객체 중 `복제`나 `이동`에 대한 기능을 지원하지 않는 객체가 하나라도 있다면, `5의 규칙`을 지켜야 하며, 반대로 모든 객체가 `복제`와 `이동`에 대한 기능이 지원된다면 `0의 규칙`을 따르면 된다.

여기서 주의할 것은 `5의 규칙`이 필요 없다는 것이 아니고, `0의 규칙`을 준수하는 것이 맞다는 것이 아니라, `복제`와 `이동`이 필요한지 여부와 그 클래스의 기능과 역할에 맞게 `5의 규칙`과 `0의 규칙`을 준수해서 지키는 것이 중요하다.

# 참고문헌

- 전문가를 위한 C++(마크 그레고리 / 한빛미디어)
- [The rule of three/five/zero](https://en.cppreference.com/w/cpp/language/rule_of_three)
- [C++의 Rule of Zero](https://pula39.tistory.com/8)
- [The Rule of Zero](https://blog.feabhas.com/2015/01/the-rule-of-zero/)
- [The Rule of Zero in C++](https://www.fluentcpp.com/2019/04/23/the-rule-of-zero-zero-constructor-zero-calorie/)
- [3/5의 규칙](https://runebook.dev/ko/docs/cpp/language/rule_of_three)