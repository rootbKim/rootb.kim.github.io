---
layout: archive
title: A* 알고리즘
tags: [Algorithm]
category: "Programming"
---

길 찾기 방법으로 가장 많이 사용되는 알고리즘 중 하나인 A* 알고리즘에 대해 정리하고, A* 알고리즘을 구현한 C++ 예제에 대해서도 정리한다.

# Heuristic 이란?

휴리스틱(heuristics) 또는 발견법(發見法)이란 **불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법**이다.

문제해결에 있어서 복잡한 문제의 경우 초기에는 휴리스틱을 이용하여 과제를 단순화시킨 후 후기에 규범적(normative)인 의사결정 규칙을 사용하고, 단순한 과업 상황에서는 처음부터 최종 의사결정에 이르기까지 규범적 규칙을 이용하여 이를 해결하려한다는 가설은 허버트 사이먼(Herbert A. Simon)이 주창한 ‘제한된 합리성(bounded rationality)’에서 시작되었고 앨런 뉴얼(Allen Newell) 등이 공동 참여하였다. ‘제한된 합리성’이란 다양한 의사결정 상황에서 인간의 인지적인 한계로 인해 발생하는 의사결정 문제를 인지적 한계 안에서 다룰 수 있는 범위로 축소시키고, **간단해진 과업의 수행에 한해 규범적 규칙을 이용한다는 것**을 의미한다.

휴리스틱의 어원은 라틴어의 ‘heuristicus’ 와 그리스어 ‘heuriskein’ 에서부터 시작되었으며, “찾아내다(find out)” 그리고 발견하다(discover)”라는 의미를 뜻한다.

# A* 알고리즘이란?

정보과학 분야에 있어서, A* 알고리즘(A* algorithm 에이 스타 알고리즘)은 주어진 출발 꼭짓점에서부터 목표 꼭짓점까지 가는 최단 경로를 찾아내는(다시 말해 주어진 목표 꼭짓점까지 가는 최단 경로임을 판단할 수 있는 테스트를 통과하는) **그래프 탐색 알고리즘** 중 하나이다. 이 알고리즘은 다익스트라 알고리즘과 유사하나 차이점은 각 꼭짓점 ***x*** 에 대해 그 꼭짓점을 통과하는 최상의 경로를 추정하는 순위값인 "휴리스틱 추정값" ***h(x)*** 을 매기는 방법을 이용한다는 것이다. 이 알고리즘은 이 휴리스틱 추정값의 순서로 꼭짓점을 방문한다. 그러므로 A* 알고리즘을 너비 우선 탐색의 한 예로 분류할 수 있다.

이 알고리즘은 1968년 피터 하트, 닐스 닐슨, 버트램 라팰이 처음 기술하였다. 그 3명의 논문에서, 이 알고리즘은 A 알고리즘(algorithm A)이라고 불렸다. 적절한 휴리스틱을 가지고 이 알고리즘을 사용하면 최적(optimal)이 된다. 그러므로 A* 알고리즘이라고 불린다.

A* 알고리즘은 출발 꼭짓점으로부터 목표 꼭짓점까지의 최적 경로를 탐색하기 위한 것이다. 이를 위해서는 각각의 꼭짓점에 대한 평가 함수를 정의해야 한다.

이는 즉, optimal한 해를 찾는 것이 아닌 방법론적(추론적)인 접근을 통해 해를 찾는 것이다.

A* 알고리즘의 핵심은 시작점부터 목적지 노드까지 갈 수 있는 모든 경로 중에 최소 비용으로 갈 수 있는 경로를 탐색하는 것으로, 이 경로의 비용을 계산해내는 것이다.

A*의 cost function은 다음과 같다.

---
***f(n) = g(n) + h(n)***

***g(n)*** : 출발 꼭짓점으로부터 꼭짓점 ***n*** 까지의 경로 가중치

***h(n)*** : 꼭짓점 ***n*** 으로부터 목표 꼭짓점까지의 추정 경로 가중치

---

일반적으로 ***g(n)*** 은 출발 꼭지점으로부터 n 꼭지점 까지의 경로 거리이며, 측정이 가능하다.
반면, ***h(n)*** 은 n 부터 도착 꼭지점 까지의 예상 cost인데, 이는 일반적으로 Manhattan Distance를 사용하며, Chebyshev Distance 또는 Euclidean Distance를 사용하기도 한다.

일반적인 A* 알고리즘은 이렇게 정의되고 사용이 되나, A* 알고리즘은 **사용환경에 따라 Heuristic을 정의하는 방법**에 따라 수행 결과물이 달라지기도 한다.

A* 알고리즘을 사용하고자 하는 환경에 맞게 Heuristic을 설정하면 더 좋은 결과를 만들어낼 수 있다. 단순 Manhattan Distance 만을 이용하기 보다는 주어진 환경에 맞게 Heuristic 계산 함수를 정의함으로써 실제 환경에서 경로 탐색의 효율성을 높일 수 있다.

## A* 알고리즘 예시 설명

A* 알고리즘을 설명하기 위해 다음과 같은 맵에서의 길찾기 예시를 보고자 한다.

<img src="/assets/img/posts/221222_astar_1.png">

---

위와 같은 맵을 다음과 같이 노드-링크 구조로 표현했다고 가정한다.

<img src="/assets/img/posts/221222_astar_2.png">

---

각 노드는 다음과 같은 좌표값을 가지고 있고, 이 좌표 기준으로 노드 간의 거리 기반으로 휴리스틱 값을 계산한다.

<img src="/assets/img/posts/221222_astar_3.png">

---

이 때 2번 노드에서 14번 노드로 이동 경로를 찾는 상황을 가정한다.

<img src="/assets/img/posts/221222_astar_4.png">

---

A* 알고리즘으로 경로를 찾기 위해 다음과 같이 O 테이블과 C 테이블을 작성한다. O는 Open List, C는 Closed List 이다. O 테이블에는 최단 경로를 찾기 위해 탐색하는 노드에 대한 휴리스틱 값을 저장하고, C 테이블에는 최단 경로에 사용될 노드의 정보를 저장한다.

먼저 출발 노드인 2번 노드는 C 테이블에 저장하고, 2번 노드와 연결된 1, 5, 3 노드를 O 테이블에 저장한다. 이 때, F, G, H, Parent를 작성하는데, F는 G+H 값이고, G 값은 출발 노드로부터 현재 노드까지의 비용 값이고, H 값은 값은 현재 노드에서 목적지 노드 까지의 비용 값이다. 이 예제에서는 G 값과 H 값 모두 거리 값을 이용하며, H 값으로 현재 노드에서 목적지 까지의 직선 거리를 기준으로 한다.

물론 비용을 계산하는 방법이 거리가 아닌 다른 휴리스틱 요소가 될 수 있다.

1번 노드를 O 테이블에 작성하면, G 값은 2번 노드로부터 거리 값이 15이고, H 값은 목적지인 14번 노드까지의 직선 거리로 40.3이 된다. 따라서 F 값은 55.3이 된다. Parent 값은 이전 노드인 2번이 될 것이다.

이와 같은 방식으로 3, 5 노드에 대해 작성한다.

<img src="/assets/img/posts/221222_astar_5.png">

---

1,3,5 노드 중 F가 가장 작은 값은 5번 노드이다. 이 5번 노드를 C 테이블에 저장하고, 5번 노드와 연결된 노드에 대하여 휴리스틱 값을 계산하여 O 테이블에 저장한다. 단, 이미 C 테이블에 저장되어 있는 노드에 대해서는 계산하지 않는다.

5번 노드와 연결된 노드는 4, 6번 노드이다. 4번노드의 G 값은 5번 노드의 G값 + 5번 노드로부터의 거리이고, H 값은 14번 노드까지의 거리인 36.4가 되어, 최종 61.4가 되고, Parent Node는 5번이 된다.. 6번 노드도 이와 같은 방식으로 계산하여 O 테이블에 저장한다.

<img src="/assets/img/posts/221222_astar_6.png">

---

O 테이블 중 가장 F 값이 낮은 3번 노드를 C에 넣고, 3과 연결된 6, 7에 대하여 O 테이블에 작성한다. 이 때 6번 노드는 이전 5번 노드와 연결되어 있었기 때문에 계산이 되어 O 테이블에 저장이 되어있는 것을 볼 수 있다. O 테이블에는 중복된 값이 계산이 되면 F 값이 더 작은 값을 선택하여 O 테이블에 저장을 한다. 단, 여기서는 두 개의 6번 노드에 대한 F 계산 값이 동일하므로, 이전의 값을 유지하고, 현재 계산된 값은 버리는 규칙을 적용한다.

<img src="/assets/img/posts/221222_astar_7.png">

<img src="/assets/img/posts/221222_astar_8.png">

---

이전과 같은 방식으로 O 테이블 중 F 값이 가장 낮은 노드를 C 테이블에 넣는다. 6번 노드가 F 값이 가장 낮으므로 C 테이블에 넣고, 6번 노드와 연결된 7번 14번 노드에 대하여 O 테이블에 넣는다. 여기서도 O 테이블에서 7번 노드가 중복되는데, Parent Node가 3인 7번 노드가 F 값이 낮으므로 해당 값을 저장하고, 이번에 계산된 값은 버린다.

<img src="/assets/img/posts/221222_astar_9.png">

<img src="/assets/img/posts/221222_astar_10.png">

---

O 테이블에서 F 값이 가장 낮은 노드는 14번 노드이고, 이를 C 테이블에 넣는다. 14번 노드는 목적지 노드이고, 목적지 노드가 C 테이블에 저장되었으므로, 탐색을 종료한다.

경로의 결과는 C 테이블에서 찾을 수 있는데, 14-6-5-2의 역순으로 찾을 수 있다. 따라서 2번 노드에서 14번 노드로 이동하기 위해 가장 최소 비용이 드는 경로는 2-5-6-14 임을 알 수 있다.

<img src="/assets/img/posts/221222_astar_11.png">

이와 같은 A* 알고리즘을 이용해서, 주어진 맵에 대한 최단경로를 찾을 수 있으며, 휴리스틱 값을 꼭 거리가 아닌 다른 요소를 이용하여 계산을 할 수도 있다.

## Pseudocode

```bash
pq.enqueue(start_node, g(start_node) + h(start_node))       // 우선순위 큐에 시작 노드를 삽입한다.

while pq is not empty       // 우선순위 큐가 비어있지 않은 동안
    node = pq.dequeue       // 우선순위 큐에서 pop한다.

    if node == goal_node    // 만약 해당 노드가 목표 노드이면 반복문을 빠져나온다.
        break

    for next_node in (next_node_begin...next_node_end)       // 해당 노드에서 이동할 수 있는 다음 노드들을 보는 동안
        pq.enqueue(next_node, g(node) + cost + h(next_node)) // 우선순위 큐에 다음 노드를 삽입한다.

return goal_node_dist       // 시작 노드에서 목표 노드까지의 거리를 출력한다.
```

# 참고문헌
* [휴리스틱 이론 WIKI](https://ko.wikipedia.org/wiki/%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1_%EC%9D%B4%EB%A1%A0)
* [A* 알고리즘 WIKI](https://ko.wikipedia.org/wiki/A*_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)